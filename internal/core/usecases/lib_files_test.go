// Code generated by MockGen. DO NOT EDIT.
// Source: internal/core/usecases/lib_files.go
//
// Generated by this command:
//
//	mockgen -source=internal/core/usecases/lib_files.go -destination=internal/core/usecases/lib_files_test.go -package=usecases
//

// Package usecases_test is a generated GoMock package.
package usecases

import (
	reflect "reflect"

	entities "github.com/sombrahq/sombra-cli/internal/core/entities"
	gomock "go.uber.org/mock/gomock"
)

// MockDirectoryManagerPort is a mock of DirectoryManagerPort interface.
type MockDirectoryManagerPort struct {
	ctrl     *gomock.Controller
	recorder *MockDirectoryManagerPortMockRecorder
	isgomock struct{}
}

// MockDirectoryManagerPortMockRecorder is the mock recorder for MockDirectoryManagerPort.
type MockDirectoryManagerPortMockRecorder struct {
	mock *MockDirectoryManagerPort
}

// NewMockDirectoryManagerPort creates a new mock instance.
func NewMockDirectoryManagerPort(ctrl *gomock.Controller) *MockDirectoryManagerPort {
	mock := &MockDirectoryManagerPort{ctrl: ctrl}
	mock.recorder = &MockDirectoryManagerPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDirectoryManagerPort) EXPECT() *MockDirectoryManagerPortMockRecorder {
	return m.recorder
}

// IsAllowed mocks base method.
func (m *MockDirectoryManagerPort) IsAllowed(fn entities.File, only, exclude []entities.Wildcard) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsAllowed", fn, only, exclude)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsAllowed indicates an expected call of IsAllowed.
func (mr *MockDirectoryManagerPortMockRecorder) IsAllowed(fn, only, exclude any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsAllowed", reflect.TypeOf((*MockDirectoryManagerPort)(nil).IsAllowed), fn, only, exclude)
}

// PathMatch mocks base method.
func (m *MockDirectoryManagerPort) PathMatch(fn entities.File, pattern entities.Wildcard) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PathMatch", fn, pattern)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PathMatch indicates an expected call of PathMatch.
func (mr *MockDirectoryManagerPortMockRecorder) PathMatch(fn, pattern any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PathMatch", reflect.TypeOf((*MockDirectoryManagerPort)(nil).PathMatch), fn, pattern)
}

// ScanTree mocks base method.
func (m *MockDirectoryManagerPort) ScanTree(dir string, only, exclude []entities.Wildcard) <-chan entities.FileScanResult {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ScanTree", dir, only, exclude)
	ret0, _ := ret[0].(<-chan entities.FileScanResult)
	return ret0
}

// ScanTree indicates an expected call of ScanTree.
func (mr *MockDirectoryManagerPortMockRecorder) ScanTree(dir, only, exclude any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScanTree", reflect.TypeOf((*MockDirectoryManagerPort)(nil).ScanTree), dir, only, exclude)
}

// MockFileManagerPort is a mock of FileManagerPort interface.
type MockFileManagerPort struct {
	ctrl     *gomock.Controller
	recorder *MockFileManagerPortMockRecorder
	isgomock struct{}
}

// MockFileManagerPortMockRecorder is the mock recorder for MockFileManagerPort.
type MockFileManagerPortMockRecorder struct {
	mock *MockFileManagerPort
}

// NewMockFileManagerPort creates a new mock instance.
func NewMockFileManagerPort(ctrl *gomock.Controller) *MockFileManagerPort {
	mock := &MockFileManagerPort{ctrl: ctrl}
	mock.recorder = &MockFileManagerPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFileManagerPort) EXPECT() *MockFileManagerPortMockRecorder {
	return m.recorder
}

// EnsureDir mocks base method.
func (m *MockFileManagerPort) EnsureDir(dir string, fn entities.File) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EnsureDir", dir, fn)
	ret0, _ := ret[0].(error)
	return ret0
}

// EnsureDir indicates an expected call of EnsureDir.
func (mr *MockFileManagerPortMockRecorder) EnsureDir(dir, fn any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnsureDir", reflect.TypeOf((*MockFileManagerPort)(nil).EnsureDir), dir, fn)
}

// Read mocks base method.
func (m *MockFileManagerPort) Read(dir string, fn entities.File) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Read", dir, fn)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Read indicates an expected call of Read.
func (mr *MockFileManagerPortMockRecorder) Read(dir, fn any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Read", reflect.TypeOf((*MockFileManagerPort)(nil).Read), dir, fn)
}

// Write mocks base method.
func (m *MockFileManagerPort) Write(dir string, fn entities.File, content []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Write", dir, fn, content)
	ret0, _ := ret[0].(error)
	return ret0
}

// Write indicates an expected call of Write.
func (mr *MockFileManagerPortMockRecorder) Write(dir, fn, content any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockFileManagerPort)(nil).Write), dir, fn, content)
}
